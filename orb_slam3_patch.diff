diff --git a/Examples/Monocular/EuRoC.yaml b/Examples/Monocular/EuRoC.yaml
index 3840eda..7da439a 100644
--- a/Examples/Monocular/EuRoC.yaml
+++ b/Examples/Monocular/EuRoC.yaml
@@ -7,10 +7,10 @@
 # When the variables are commented, the system doesn't load a previous session or not store the current one
 
 # If the LoadFile doesn't exist, the system give a message and create a new Atlas from scratch
-#System.LoadAtlasFromFile: "Session_MH01_MH02_MH03_Mono"
+#System.LoadAtlasFromFile: "test_map"
 
 # The store file is created from the current session, if a file with the same name exists it is deleted
-#System.SaveAtlasToFile: "Session_MH01_MH02_MH03_Mono"
+System.SaveAtlasToFile: "test_map"
 
 #--------------------------------------------------------------------------------------------
 # Camera Parameters. Adjust them!
@@ -74,5 +74,4 @@ Viewer.CameraLineWidth: 3.0
 Viewer.ViewpointX: 0.0
 Viewer.ViewpointY: -0.7
 Viewer.ViewpointZ: -1.8
-Viewer.ViewpointF: 500.0
-
+Viewer.ViewpointF: 500.0
\ No newline at end of file
diff --git a/Examples/Monocular/mono_euroc.cc b/Examples/Monocular/mono_euroc.cc
index fc5ed0d..7f54f5b 100644
--- a/Examples/Monocular/mono_euroc.cc
+++ b/Examples/Monocular/mono_euroc.cc
@@ -80,7 +80,7 @@ int main(int argc, char **argv)
     int fps = 20;
     float dT = 1.f/fps;
     // Create SLAM system. It initializes all system threads and gets ready to process frames.
-    ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR, false);
+    ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR, true);
     float imageScale = SLAM.GetImageScale();
 
     double t_resize = 0.f;
diff --git a/Examples/Monocular/mono_kitti.cc b/Examples/Monocular/mono_kitti.cc
index d1a4ac6..f147e6c 100644
--- a/Examples/Monocular/mono_kitti.cc
+++ b/Examples/Monocular/mono_kitti.cc
@@ -1,186 +1,41 @@
-/**
-* This file is part of ORB-SLAM3
-*
-* Copyright (C) 2017-2021 Carlos Campos, Richard Elvira, Juan J. Gómez Rodríguez, José M.M. Montiel and Juan D. Tardós, University of Zaragoza.
-* Copyright (C) 2014-2016 Raúl Mur-Artal, José M.M. Montiel and Juan D. Tardós, University of Zaragoza.
-*
-* ORB-SLAM3 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
-* License as published by the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
-* the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License along with ORB-SLAM3.
-* If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include<iostream>
-#include<algorithm>
-#include<fstream>
-#include<chrono>
-#include<iomanip>
-
-#include<opencv2/core/core.hpp>
-
-#include"System.h"
-
-using namespace std;
-
-void LoadImages(const string &strSequence, vector<string> &vstrImageFilenames,
-                vector<double> &vTimestamps);
-
-int main(int argc, char **argv)
-{
-    if(argc != 4)
-    {
-        cerr << endl << "Usage: ./mono_kitti path_to_vocabulary path_to_settings path_to_sequence" << endl;
+#include <opencv2/opencv.hpp>
+
+int main() {
+    // Open the default camera (typically the first camera)
+    cv::VideoCapture cap(0);
+    
+    // Check if the camera opened successfully
+    if (!cap.isOpened()) {
+        std::cerr << "Error: Could not open camera" << std::endl;
         return 1;
     }
-
-    // Retrieve paths to images
-    vector<string> vstrImageFilenames;
-    vector<double> vTimestamps;
-    LoadImages(string(argv[3]), vstrImageFilenames, vTimestamps);
-
-    int nImages = vstrImageFilenames.size();
-
-    // Create SLAM system. It initializes all system threads and gets ready to process frames.
-    ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR,true);
-    float imageScale = SLAM.GetImageScale();
-
-    // Vector for tracking time statistics
-    vector<float> vTimesTrack;
-    vTimesTrack.resize(nImages);
-
-    cout << endl << "-------" << endl;
-    cout << "Start processing sequence ..." << endl;
-    cout << "Images in the sequence: " << nImages << endl << endl;
-
-    // Main loop
-    double t_resize = 0.f;
-    double t_track = 0.f;
-
-    cv::Mat im;
-    for(int ni=0; ni<nImages; ni++)
-    {
-        // Read image from file
-        im = cv::imread(vstrImageFilenames[ni],cv::IMREAD_UNCHANGED); //,cv::IMREAD_UNCHANGED);
-        double tframe = vTimestamps[ni];
-
-        if(im.empty())
-        {
-            cerr << endl << "Failed to load image at: " << vstrImageFilenames[ni] << endl;
-            return 1;
+    
+    // Create a window to display the camera feed
+    cv::namedWindow("Camera Feed", cv::WINDOW_NORMAL);
+    
+    // Main loop to capture and display frames from the camera
+    while (true) {
+        cv::Mat frame;
+        // Capture frame-by-frame
+        cap >> frame;
+        
+        // Check if the frame is empty
+        if (frame.empty()) {
+            std::cerr << "Error: Frame is empty" << std::endl;
+            break;
         }
-
-        if(imageScale != 1.f)
-        {
-#ifdef REGISTER_TIMES
-    #ifdef COMPILEDWITHC14
-            std::chrono::steady_clock::time_point t_Start_Resize = std::chrono::steady_clock::now();
-    #else
-            std::chrono::monotonic_clock::time_point t_Start_Resize = std::chrono::monotonic_clock::now();
-    #endif
-#endif
-            int width = im.cols * imageScale;
-            int height = im.rows * imageScale;
-            cv::resize(im, im, cv::Size(width, height));
-#ifdef REGISTER_TIMES
-    #ifdef COMPILEDWITHC14
-            std::chrono::steady_clock::time_point t_End_Resize = std::chrono::steady_clock::now();
-    #else
-            std::chrono::monotonic_clock::time_point t_End_Resize = std::chrono::monotonic_clock::now();
-    #endif
-            t_resize = std::chrono::duration_cast<std::chrono::duration<double,std::milli> >(t_End_Resize - t_Start_Resize).count();
-            SLAM.InsertResizeTime(t_resize);
-#endif
-        }
-
-#ifdef COMPILEDWITHC14
-        std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
-#else
-        std::chrono::monotonic_clock::time_point t1 = std::chrono::monotonic_clock::now();
-#endif
-
-        // Pass the image to the SLAM system
-        SLAM.TrackMonocular(im,tframe,vector<ORB_SLAM3::IMU::Point>(), vstrImageFilenames[ni]);
-
-#ifdef COMPILEDWITHC14
-        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
-#else
-        std::chrono::monotonic_clock::time_point t2 = std::chrono::monotonic_clock::now();
-#endif
-
-#ifdef REGISTER_TIMES
-            t_track = t_resize + std::chrono::duration_cast<std::chrono::duration<double,std::milli> >(t2 - t1).count();
-            SLAM.InsertTrackTime(t_track);
-#endif
-
-        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();
-
-        vTimesTrack[ni]=ttrack;
-
-        // Wait to load the next frame
-        double T=0;
-        if(ni<nImages-1)
-            T = vTimestamps[ni+1]-tframe;
-        else if(ni>0)
-            T = tframe-vTimestamps[ni-1];
-
-        if(ttrack<T)
-            usleep((T-ttrack)*1e6);
-    }
-
-    // Stop all threads
-    SLAM.Shutdown();
-
-    // Tracking time statistics
-    sort(vTimesTrack.begin(),vTimesTrack.end());
-    float totaltime = 0;
-    for(int ni=0; ni<nImages; ni++)
-    {
-        totaltime+=vTimesTrack[ni];
+        
+        // Display the frame in the window
+        cv::imshow("Camera Feed", frame);
+        
+        // Check for ESC key press to exit the loop
+        if (cv::waitKey(1) == 27) // ESC key
+            break;
     }
-    cout << "-------" << endl << endl;
-    cout << "median tracking time: " << vTimesTrack[nImages/2] << endl;
-    cout << "mean tracking time: " << totaltime/nImages << endl;
-
-    // Save camera trajectory
-    SLAM.SaveKeyFrameTrajectoryTUM("KeyFrameTrajectory.txt");    
-
+    
+    // Release the camera and close all windows
+    cap.release();
+    cv::destroyAllWindows();
+    
     return 0;
-}
-
-void LoadImages(const string &strPathToSequence, vector<string> &vstrImageFilenames, vector<double> &vTimestamps)
-{
-    ifstream fTimes;
-    string strPathTimeFile = strPathToSequence + "/times.txt";
-    fTimes.open(strPathTimeFile.c_str());
-    while(!fTimes.eof())
-    {
-        string s;
-        getline(fTimes,s);
-        if(!s.empty())
-        {
-            stringstream ss;
-            ss << s;
-            double t;
-            ss >> t;
-            vTimestamps.push_back(t);
-        }
-    }
-
-    string strPrefixLeft = strPathToSequence + "/image_0/";
-
-    const int nTimes = vTimestamps.size();
-    vstrImageFilenames.resize(nTimes);
-
-    for(int i=0; i<nTimes; i++)
-    {
-        stringstream ss;
-        ss << setfill('0') << setw(6) << i;
-        vstrImageFilenames[i] = strPrefixLeft + ss.str() + ".png";
-    }
-}
+}
\ No newline at end of file
diff --git a/Examples/Monocular/mono_tum.cc b/Examples/Monocular/mono_tum.cc
index 97c91cf..a97bd84 100644
--- a/Examples/Monocular/mono_tum.cc
+++ b/Examples/Monocular/mono_tum.cc
@@ -1,78 +1,54 @@
-/**
-* This file is part of ORB-SLAM3
-*
-* Copyright (C) 2017-2021 Carlos Campos, Richard Elvira, Juan J. Gómez Rodríguez, José M.M. Montiel and Juan D. Tardós, University of Zaragoza.
-* Copyright (C) 2014-2016 Raúl Mur-Artal, José M.M. Montiel and Juan D. Tardós, University of Zaragoza.
-*
-* ORB-SLAM3 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
-* License as published by the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
-* the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License along with ORB-SLAM3.
-* If not, see <http://www.gnu.org/licenses/>.
-*/
-
 #include<iostream>
 #include<algorithm>
 #include<fstream>
 #include<chrono>
 
 #include<opencv2/core/core.hpp>
-
+#include<opencv2/highgui/highgui.hpp>
 #include<System.h>
 
 using namespace std;
 
-void LoadImages(const string &strFile, vector<string> &vstrImageFilenames,
-                vector<double> &vTimestamps);
-
 int main(int argc, char **argv)
-{
-    if(argc != 4)
+{  
+    if(argc != 3)
     {
-        cerr << endl << "Usage: ./mono_tum path_to_vocabulary path_to_settings path_to_sequence" << endl;
+        cerr << endl << "Usage: ./mono_euroc path_to_vocabulary path_to_settings" << endl;
         return 1;
     }
 
-    // Retrieve paths to images
-    vector<string> vstrImageFilenames;
-    vector<double> vTimestamps;
-    string strFile = string(argv[3])+"/rgb.txt";
-    LoadImages(strFile, vstrImageFilenames, vTimestamps);
-
-    int nImages = vstrImageFilenames.size();
-
     // Create SLAM system. It initializes all system threads and gets ready to process frames.
-    ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR,true);
+    ORB_SLAM3::System SLAM(argv[1], argv[2], ORB_SLAM3::System::MONOCULAR, true);
     float imageScale = SLAM.GetImageScale();
 
-    // Vector for tracking time statistics
-    vector<float> vTimesTrack;
-    vTimesTrack.resize(nImages);
+    // Open the USB camera
+    cv::VideoCapture cap(0); // Change the number to select the desired camera
+    if(!cap.isOpened())
+    {
+        cerr << "Error: Could not open camera" << endl;
+        return -1;
+    }
 
-    cout << endl << "-------" << endl;
-    cout << "Start processing sequence ..." << endl;
-    cout << "Images in the sequence: " << nImages << endl << endl;
+    // Set camera parameters (optional)
+    cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
+    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
+    cap.set(cv::CAP_PROP_FPS, 30);
 
+    // Vector for tracking time statistics
+    vector<float> vTimesTrack;
     double t_resize = 0.f;
     double t_track = 0.f;
 
     // Main loop
     cv::Mat im;
-    for(int ni=0; ni<nImages; ni++)
+    while(true)
     {
-        // Read image from file
-        im = cv::imread(string(argv[3])+"/"+vstrImageFilenames[ni],cv::IMREAD_UNCHANGED); //,cv::IMREAD_UNCHANGED);
-        double tframe = vTimestamps[ni];
+        // Capture frame from camera
+        cap >> im;
 
         if(im.empty())
         {
-            cerr << endl << "Failed to load image at: "
-                 << string(argv[3]) << "/" << vstrImageFilenames[ni] << endl;
+            cerr << endl << "Failed to capture image" << endl;
             return 1;
         }
 
@@ -99,86 +75,42 @@ int main(int argc, char **argv)
 #endif
         }
 
-#ifdef COMPILEDWITHC14
+    #ifdef COMPILEDWITHC14
         std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
-#else
+    #else
         std::chrono::monotonic_clock::time_point t1 = std::chrono::monotonic_clock::now();
-#endif
+    #endif
 
         // Pass the image to the SLAM system
-        SLAM.TrackMonocular(im,tframe);
+        double tframe = std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::steady_clock::now().time_since_epoch()).count();
+        SLAM.TrackMonocular(im, tframe); // TODO change to monocular_inertial
 
-#ifdef COMPILEDWITHC14
+    #ifdef COMPILEDWITHC14
         std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
-#else
+    #else
         std::chrono::monotonic_clock::time_point t2 = std::chrono::monotonic_clock::now();
-#endif
+    #endif
 
 #ifdef REGISTER_TIMES
-            t_track = t_resize + std::chrono::duration_cast<std::chrono::duration<double,std::milli> >(t2 - t1).count();
-            SLAM.InsertTrackTime(t_track);
+        t_track = t_resize + std::chrono::duration_cast<std::chrono::duration<double,std::milli> >(t2 - t1).count();
+        SLAM.InsertTrackTime(t_track);
 #endif
 
-        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();
-
-        vTimesTrack[ni]=ttrack;
+        double ttrack = std::chrono::duration_cast<std::chrono::duration<double>>(t2 - t1).count();
+        vTimesTrack.push_back(ttrack);
 
-        // Wait to load the next frame
-        double T=0;
-        if(ni<nImages-1)
-            T = vTimestamps[ni+1]-tframe;
-        else if(ni>0)
-            T = tframe-vTimestamps[ni-1];
-
-        if(ttrack<T)
-            usleep((T-ttrack)*1e6);
+        // Display the image
+        cv::imshow("Frame", im);
+        if(cv::waitKey(1) == 27) // Exit on ESC key
+            break;
     }
 
     // Stop all threads
     SLAM.Shutdown();
 
-    // Tracking time statistics
-    sort(vTimesTrack.begin(),vTimesTrack.end());
-    float totaltime = 0;
-    for(int ni=0; ni<nImages; ni++)
-    {
-        totaltime+=vTimesTrack[ni];
-    }
-    cout << "-------" << endl << endl;
-    cout << "median tracking time: " << vTimesTrack[nImages/2] << endl;
-    cout << "mean tracking time: " << totaltime/nImages << endl;
-
     // Save camera trajectory
-    SLAM.SaveKeyFrameTrajectoryTUM("KeyFrameTrajectory.txt");
+    SLAM.SaveTrajectoryEuRoC("CameraTrajectory.txt");
+    SLAM.SaveKeyFrameTrajectoryEuRoC("KeyFrameTrajectory.txt");
 
     return 0;
-}
-
-void LoadImages(const string &strFile, vector<string> &vstrImageFilenames, vector<double> &vTimestamps)
-{
-    ifstream f;
-    f.open(strFile.c_str());
-
-    // skip first three lines
-    string s0;
-    getline(f,s0);
-    getline(f,s0);
-    getline(f,s0);
-
-    while(!f.eof())
-    {
-        string s;
-        getline(f,s);
-        if(!s.empty())
-        {
-            stringstream ss;
-            ss << s;
-            double t;
-            string sRGB;
-            ss >> t;
-            vTimestamps.push_back(t);
-            ss >> sRGB;
-            vstrImageFilenames.push_back(sRGB);
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/include/Viewer.h b/include/Viewer.h
index 920c628..9098346 100644
--- a/include/Viewer.h
+++ b/include/Viewer.h
@@ -49,6 +49,8 @@ public:
     // frame. Drawing is refreshed according to the camera fps. We use Pangolin.
     void Run();
 
+    void OrigRun();
+
     void RequestFinish();
 
     void RequestStop();
diff --git a/src/Viewer.cc b/src/Viewer.cc
index 18f23f0..0754c68 100644
--- a/src/Viewer.cc
+++ b/src/Viewer.cc
@@ -164,6 +164,192 @@ void Viewer::Run()
     mbFinished = false;
     mbStopped = false;
 
+    // First window
+    pangolin::CreateWindowAndBind("Map Viewer: Original", 1024, 768);
+    glEnable(GL_DEPTH_TEST);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    pangolin::CreatePanel("menu").SetBounds(0.0, 1.0, 0.0, pangolin::Attach::Pix(175));
+
+    // Menu options
+    pangolin::Var<bool> menuFollowCamera("menu.Follow Camera", false, true);
+    pangolin::Var<bool> menuShowPoints("menu.Show Points", true, true);
+    pangolin::Var<bool> menuShowKeyFrames("menu.Show KeyFrames", true, true);
+    pangolin::Var<bool> menuShowGraph("menu.Show Graph", false, true);
+    pangolin::Var<bool> menuShowInertialGraph("menu.Show Inertial Graph", true, true);
+    pangolin::Var<bool> menuLocalizationMode("menu.Localization Mode", false, true);
+    pangolin::Var<bool> menuReset("menu.Reset", false, false);
+    pangolin::Var<bool> menuStop("menu.Stop", false, false);
+    pangolin::Var<bool> menuStepByStep("menu.Step By Step", false, true);
+    pangolin::Var<bool> menuStep("menu.Step", false, false);
+    pangolin::Var<bool> menuShowOptLba("menu.Show LBA opt", false, true);
+
+    pangolin::OpenGlRenderState s_cam(
+        pangolin::ProjectionMatrix(1024, 768, mViewpointF, mViewpointF, 512, 389, 0.1, 1000),
+        pangolin::ModelViewLookAt(mViewpointX, mViewpointY, mViewpointZ, 0, 0, 0, 0.0, -1.0, 0.0)
+    );
+
+    pangolin::View& d_cam = pangolin::CreateDisplay()
+        .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f)
+        .SetHandler(new pangolin::Handler3D(s_cam));
+
+    // Second window
+    pangolin::CreateWindowAndBind("Map Viewer: Bird's-Eye View", 1024, 768);
+    pangolin::OpenGlRenderState s_cam_bird(
+        pangolin::ProjectionMatrix(1024, 768, 3000, 3000, 512, 389, 0.1, 10000),
+        pangolin::ModelViewLookAt(0, 50, 0, 0, 0, 0, 0.0, 0.0, 1.0)
+    );
+    pangolin::View& d_cam2 = pangolin::CreateDisplay()
+        .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f)
+        .SetHandler(new pangolin::Handler3D(s_cam_bird));
+
+    // Shared state variables
+    pangolin::OpenGlMatrix Twc, Twr;
+    Twc.SetIdentity();
+    pangolin::OpenGlMatrix Ow; // Oriented with g in the z axis
+    Ow.SetIdentity();
+    cv::namedWindow("ORB-SLAM3: Current Frame");
+
+    bool bFollow = true;
+    bool bLocalizationMode = false;
+    bool bStepByStep = false;
+    bool bCameraView = true;
+
+    if (mpTracker->mSensor == mpSystem->MONOCULAR || mpTracker->mSensor == mpSystem->STEREO || mpTracker->mSensor == mpSystem->RGBD)
+    {
+        menuShowGraph = true;
+    }
+
+    float trackedImageScale = mpTracker->GetImageScale();
+
+    cout << "Starting the Viewer" << endl;
+
+    while (1)
+    {
+        // Update logic shared between windows
+        if (mbStopTrack)
+        {
+            menuStepByStep = true;
+            mbStopTrack = false;
+        }
+
+        if (menuFollowCamera && bFollow)
+        {
+            s_cam.Follow(bCameraView ? Twc : Ow);
+        }
+        else if (menuFollowCamera && !bFollow)
+        {
+            s_cam.SetProjectionMatrix(pangolin::ProjectionMatrix(1024, 768, bCameraView ? mViewpointF : 3000, bCameraView ? mViewpointF : 3000, 512, 389, 0.1, 1000));
+            s_cam.SetModelViewMatrix(pangolin::ModelViewLookAt(bCameraView ? mViewpointX : 0, bCameraView ? mViewpointY : 0.01, bCameraView ? mViewpointZ : 10, 0, 0, 0, 0.0, bCameraView ? -1.0 : 0.0, 0.0));
+            s_cam.Follow(bCameraView ? Twc : Ow);
+            bFollow = true;
+        }
+        else if (!menuFollowCamera && bFollow)
+        {
+            bFollow = false;
+        }
+
+        // Update for the first window
+        pangolin::BindToContext("ORB-SLAM3: Map Viewer");
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);  // Set background color to white
+        mpMapDrawer->GetCurrentOpenGLCameraMatrix(Twc, Ow);
+        d_cam.Activate(s_cam);
+        mpMapDrawer->DrawCurrentCamera(Twc);
+        if (menuShowKeyFrames || menuShowGraph || menuShowInertialGraph || menuShowOptLba)
+            mpMapDrawer->DrawKeyFrames(menuShowKeyFrames, menuShowGraph, menuShowInertialGraph, menuShowOptLba);
+        if (menuShowPoints)
+            mpMapDrawer->DrawMapPoints();
+        pangolin::FinishFrame();
+
+        // Update for the second window (bird's eye view)
+        pangolin::BindToContext("ORB-SLAM3: Map Viewer 2");
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);  // Set background color to white
+        d_cam2.Activate(s_cam_bird);
+        mpMapDrawer->DrawCurrentCamera(Twc);
+        if (menuShowKeyFrames || menuShowGraph || menuShowInertialGraph || menuShowOptLba)
+            mpMapDrawer->DrawKeyFrames(menuShowKeyFrames, menuShowGraph, menuShowInertialGraph, menuShowOptLba);
+        if (menuShowPoints)
+            mpMapDrawer->DrawMapPoints();
+        pangolin::FinishFrame();
+
+        // Display current frame
+        cv::Mat toShow;
+        cv::Mat im = mpFrameDrawer->DrawFrame(trackedImageScale);
+        if (both)
+        {
+            cv::Mat imRight = mpFrameDrawer->DrawRightFrame(trackedImageScale);
+            cv::hconcat(im, imRight, toShow);
+        }
+        else
+        {
+            toShow = im;
+        }
+
+        if (mImageViewerScale != 1.f)
+        {
+            int width = toShow.cols * mImageViewerScale;
+            int height = toShow.rows * mImageViewerScale;
+            cv::resize(toShow, toShow, cv::Size(width, height));
+        }
+
+        cv::imshow("ORB-SLAM3: Current Frame", toShow);
+        cv::waitKey(mT);
+
+        // Handle reset and stop commands
+        if (menuReset)
+        {
+            menuShowGraph = true;
+            menuShowInertialGraph = true;
+            menuShowKeyFrames = true;
+            menuShowPoints = true;
+            menuLocalizationMode = false;
+            if (bLocalizationMode)
+                mpSystem->DeactivateLocalizationMode();
+            bLocalizationMode = false;
+            bFollow = true;
+            menuFollowCamera = true;
+            mpSystem->ResetActiveMap();
+            menuReset = false;
+        }
+
+        if (menuStop)
+        {
+            if (bLocalizationMode)
+                mpSystem->DeactivateLocalizationMode();
+
+            // Stop all threads
+            mpSystem->Shutdown();
+
+            // Save camera trajectory
+            mpSystem->SaveTrajectoryEuRoC("CameraTrajectory.txt");
+            mpSystem->SaveKeyFrameTrajectoryEuRoC("KeyFrameTrajectory.txt");
+            menuStop = false;
+        }
+
+        if (Stop())
+        {
+            while (isStopped())
+            {
+                usleep(3000);
+            }
+        }
+
+        if (CheckFinish())
+            break;
+    }
+
+    SetFinish();
+}
+
+
+
+void Viewer::OrigRun()
+{
+    mbFinished = false;
+    mbStopped = false;
+
     pangolin::CreateWindowAndBind("ORB-SLAM3: Map Viewer",1024,768);
 
     // 3D Mouse handler requires depth testing to be enabled
